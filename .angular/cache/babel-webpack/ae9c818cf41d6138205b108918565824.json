{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Inject, NgModule } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { map } from 'rxjs/operators';\n/**\n * @desc checks if the condition is met and returns its value\n * @param condition - the condition to check\n * @param errorMessage - the error message to be shown if the condition is not met\n * @return any\n */\n\nfunction checkIfConditionMet(condition, errorMessage) {\n  const conditionMet = condition();\n\n  if (!conditionMet.met) {\n    console.error(errorMessage);\n    throw Error(errorMessage);\n  }\n\n  return conditionMet.value;\n}\n\nclass GentlemanStateObject {\n  constructor(state, stateProperties) {\n    this.stateProperties = {};\n    this.state = state;\n    this.stateProperties = stateProperties;\n    this.observableSubject = new BehaviorSubject(state);\n  }\n  /**\n   * @desc returns the observable that contains the state for async operations - it listens for changes\n   * @return Observable\n   */\n\n\n  getObservable() {\n    return this.observableSubject.asObservable();\n  }\n  /**\n   * @desc returns the state properties object\n   * @return StateProperties\n   */\n\n\n  getStateProperties() {\n    return this.stateProperties;\n  }\n  /**\n   * @desc unsubscribes from the observable\n   * @return void\n   */\n\n\n  unsubscribe() {\n    this.observableSubject.unsubscribe();\n  }\n  /**\n   * @desc returns the value of the state at the time of the call\n   * @return any\n   */\n\n\n  getStateSnapshot() {\n    return Object.assign({}, this.state);\n  }\n  /**\n   * @desc returns the value of a property of the state at the time of the call\n   * @param property - the name of the requested property\n   * @return any\n   */\n\n\n  getPropertyFromState(property) {\n    return this.state[property];\n  }\n  /**\n   * @desc returns the value of a property of the state for async operations - it listens for changes\n   * @param property - the name of the requested property\n   * @return Observable\n   */\n\n\n  getPropertyFromObservable(property) {\n    return this.getObservable().pipe(map(s => this.checkIfPropertyExists(s, property)));\n  }\n  /**\n   * @desc sets the value for a certain property inside the state, triggers an async event\n   * @param value - the value for the requested property\n   * @param property - the name of the requested property\n   * @param emit - if true it will trigger an async event\n   * @return void\n   */\n\n\n  setObservableValues(value, property = null, emit = true) {\n    this.setStateValues(value, property);\n\n    if (emit) {\n      this.observableSubject.next(this.state);\n    }\n  }\n  /**\n   * @desc sets the value for a certain property inside the state, doesn't triggers an async event\n   * @param value - the value for the requested property\n   * @param property - the name of the requested property, if no property it will try to patch the values into the state\n   * @return void\n   */\n\n\n  setStateValues(value, property) {\n    if (property && this.checkIfPropertyExists(this.state, property) !== undefined) {\n      this.state[property] = value;\n    } else {\n      this.state = Object.assign(Object.assign({}, this.state), value);\n    }\n  }\n  /**\n   * @desc resets the state\n   * @return void\n   */\n\n\n  resetState() {\n    this.state = {};\n  }\n  /**\n   * @desc checks if the selected property exists inside the state\n   * @param state - the state of the observable, the object that represents what the observable is going to contain\n   * @param property - the selected property\n   * @return any\n   */\n\n\n  checkIfPropertyExists(state, property) {\n    const condition = () => {\n      return {\n        met: state.hasOwnProperty(property),\n        value: state[property]\n      };\n    };\n\n    return checkIfConditionMet(() => condition(), 'Selected property not found ! check if the key is correct and exists');\n  }\n\n}\n\nlet GentlemanStateService = /*#__PURE__*/(() => {\n  class GentlemanStateService {\n    constructor(sourceOfTruthKeys) {\n      this.observerArray = new Map();\n      sourceOfTruthKeys.forEach(k => {\n        const {\n          state,\n          stateProperties\n        } = k;\n        this.createObservable(k.key, state, stateProperties);\n      });\n    }\n    /**\n     * @desc it checks if the searched object exists, if not it throws an errors and stops the execution.\n     * @param gentlemanObject - GentlemanStateObject | undefined\n     * @return GentlemanStateObject\n     */\n\n\n    static checkIfFound(gentlemanObject) {\n      const condition = () => {\n        return {\n          met: !!gentlemanObject,\n          value: gentlemanObject\n        };\n      };\n\n      return checkIfConditionMet(() => condition(), \"Observable item not found ! check if the key is correct and exists\");\n    }\n    /**\n     * @desc it creates and observable and adds it to the observable array.\n     * @param key - the key to be used to represent the observable item inside the array\n     * @param state - the state of the observable, the object that represents what the observable is going to contain\n     * @param stateProperties - the properties of the state\n     * @return void\n     */\n\n\n    createObservable(key, state, stateProperties) {\n      const found = this.observerArray.has(key);\n\n      if (found) {\n        console.log(`the key : ${key}, already exists as an entity so it will be ignored`);\n      } else {\n        const gentlemanObject = new GentlemanStateObject(state, stateProperties);\n        this.observerArray.set(key, gentlemanObject);\n      }\n    }\n    /**\n     * @desc it returns the selected observable using the provided key.\n     * @param key - the key to be used to represent the observable item inside the array\n     * @return GentlemanStateObject\n     */\n\n\n    getEntity(key) {\n      const observableArrayItem = GentlemanStateService.checkIfFound(this.observerArray.get(key));\n      return observableArrayItem;\n    }\n    /**\n     * @desc it emits a new value into the selected observable using the provided key.\n     * @param key - the key to be used to represent the observable item inside the array\n     * @param data - the data to be emitted inside the selected observable\n     * @return void\n     */\n\n\n    emitValue(key, data) {\n      const observableArrayItem = GentlemanStateService.checkIfFound(this.observerArray.get(key));\n      observableArrayItem.setObservableValues(data);\n    }\n    /**\n     * @desc it destroys an object from the observable array.\n     * @param key - the key to be used to represent the observable item inside the array\n     * @return void\n     */\n\n\n    destroyObservable(key) {\n      const selectedObservable = GentlemanStateService.checkIfFound(this.observerArray.get(key));\n      selectedObservable.unsubscribe();\n      this.observerArray.delete(key);\n    }\n\n  }\n\n  GentlemanStateService.ɵfac = function GentlemanStateService_Factory(t) {\n    return new (t || GentlemanStateService)(i0.ɵɵinject(\"sourceOfTruthKeys\"));\n  };\n\n  GentlemanStateService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: GentlemanStateService,\n    factory: GentlemanStateService.ɵfac,\n    providedIn: \"root\"\n  });\n  return GentlemanStateService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet GentlemanStateManagerModule = /*#__PURE__*/(() => {\n  class GentlemanStateManagerModule {\n    static forRoot(sourceOfTruthKeys) {\n      return {\n        ngModule: GentlemanStateManagerModule,\n        providers: [GentlemanStateService, {\n          provide: 'sourceOfTruthKeys',\n          useValue: sourceOfTruthKeys\n        }]\n      };\n    }\n\n  }\n\n  GentlemanStateManagerModule.ɵfac = function GentlemanStateManagerModule_Factory(t) {\n    return new (t || GentlemanStateManagerModule)();\n  };\n\n  GentlemanStateManagerModule.ɵmod = /*@__PURE__*/i0.ɵɵdefineNgModule({\n    type: GentlemanStateManagerModule\n  });\n  GentlemanStateManagerModule.ɵinj = /*@__PURE__*/i0.ɵɵdefineInjector({\n    imports: [[]]\n  });\n  return GentlemanStateManagerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of gentleman-state-manager\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { GentlemanStateManagerModule, GentlemanStateObject, GentlemanStateService }; //# sourceMappingURL=gentleman-state-manager-lib.js.map","map":null,"metadata":{},"sourceType":"module"}